# DTO Layer (Data Transfer Objects)

## üìã Overview

**Purpose:** Define API contracts for request/response objects, separate from domain entities.

**Location:** `src/main/java/com/taskmanagement/dto/`

**Pattern:** DTO Pattern - decouples API interface from database schema

**Current Status:**  
‚úÖ **MVP Phase** - Task CRUD DTOs implemented  
üî≤ **Future** - User/Project/Comment DTOs, mappers, validation groups

---

## üìÅ Current Structure

```
dto/
‚îú‚îÄ‚îÄ request/
‚îÇ   ‚îú‚îÄ‚îÄ CreateTaskRequest.java      # ‚úÖ POST /api/tasks
‚îÇ   ‚îî‚îÄ‚îÄ UpdateTaskRequest.java      # ‚úÖ PUT /api/tasks/{id}
‚îú‚îÄ‚îÄ response/
‚îÇ   ‚îú‚îÄ‚îÄ TaskResponse.java           # ‚úÖ All task endpoints
‚îÇ   ‚îî‚îÄ‚îÄ UserResponse.java           # ‚úÖ NEW: User API endpoints
‚îî‚îÄ‚îÄ README.md                       # This file
```

**Note:** Task and User response DTOs implemented. No User request DTOs (CREATE/UPDATE not implemented yet). No Project or Comment DTOs yet.

---

## üéØ Core Responsibilities

### ‚úÖ Currently Implemented

1. **Request Validation**
   - Bean Validation annotations (@NotBlank, @NotNull, @Size, etc.)
   - Meaningful error messages
   - Prevent invalid data reaching services

2. **Response Formatting**
   - Convert Task entity to TaskResponse DTO
   - Include nested DTOs (UserSummary, ProjectSummary)
   - Consistent response structure

3. **API Contract Definition**
   - Clear request/response structures
   - Type-safe interfaces
   - Documentation through code

### üî≤ Not Yet Implemented

- DTO Mappers (manual conversion in entity)
- Validation groups (create vs update)
- Pagination DTOs
- Error response DTOs (defined in exception package)
- User/Project/Comment DTOs

---

## 1. CreateTaskRequest

**Location:** [CreateTaskRequest.java](request/CreateTaskRequest.java)

**Purpose:** Request DTO for creating new tasks

**Used by:** `POST /api/tasks`

### Structure

```java
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class CreateTaskRequest {
    
    @NotBlank(message = "Task title is required")
    @Size(min = 10, max = 2000, message = "Title must be between 10 and 2000 characters")
    private String title;
    
    @NotBlank(message = "Task description is required")
    @Size(min = 10, max = 2000, message = "Description must be between 10 and 2000 characters")
    private String description;
    
    @NotNull(message = "Priority is required")
    private TaskPriority priority;  // LOW, MEDIUM, HIGH, CRITICAL
    
    @NotNull(message = "Due date is required")
    @FutureOrPresent(message = "Due date must be in the present or future")
    private LocalDateTime dueDate;
    
    @Min(value = 0, message = "Estimated hours cannot be negative")
    @Max(value = 999, message = "Estimated hours cannot exceed 999")
    private Integer estimatedHours;  // Optional
    
    @Size(max = 1000, message = "Notes cannot exceed 1000 characters")
    private String notes;  // Optional
    
    @NotNull(message = "Assignee ID is required")
    @Positive(message = "Assignee ID must be positive")
    private Long assigneeId;  // Required
    
    @NotNull(message = "Project ID is required")
    @Positive(message = "Project ID must be positive")
    private Long projectId;  // Required
}
```

### Field Rules

| Field | Required | Validation | Notes |
|-------|----------|------------|-------|
| `title` | ‚úÖ Yes | 10-2000 chars | Task title |
| `description` | ‚úÖ Yes | 10-2000 chars | Detailed description |
| `priority` | ‚úÖ Yes | Enum | LOW/MEDIUM/HIGH/CRITICAL |
| `dueDate` | ‚úÖ Yes | Future or present | Deadline |
| `estimatedHours` | ‚ùå No | 0-999 | Hours to complete |
| `notes` | ‚ùå No | Max 1000 chars | Additional notes |
| `assigneeId` | ‚úÖ Yes | Positive number | Must exist in DB |
| `projectId` | ‚úÖ Yes | Positive number | Must exist in DB |

### Example Request

```json
{
  "title": "Implement user authentication with JWT tokens",
  "description": "Add JWT-based authentication to secure API endpoints. Include token generation, validation, and refresh mechanisms.",
  "priority": "HIGH",
  "dueDate": "2025-12-20T17:00:00",
  "estimatedHours": 16,
  "notes": "Related to security epic PROJ-123",
  "assigneeId": 1,
  "projectId": 1
}
```

### Design Decisions

**Why use IDs instead of nested objects?**
```java
// ‚ùå Not this:
private User assignee;
private Project project;

// ‚úÖ This:
private Long assigneeId;
private Long projectId;
```

**Reasons:**
- Client doesn't need to send full User/Project objects
- Simpler API contract
- Service layer validates existence
- Prevents accidental entity creation

**Why not include ID, status, timestamps?**
- `id` - Auto-generated by database
- `status` - Defaults to PENDING
- `createdAt`, `updatedAt` - Auto-managed by JPA
- `completedAt` - Set when status changes to COMPLETED

---

## 2. UpdateTaskRequest

**Location:** [UpdateTaskRequest.java](request/UpdateTaskRequest.java)

**Purpose:** Request DTO for updating existing tasks (partial updates)

**Used by:** `PUT /api/tasks/{id}`

### Structure

```java
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class UpdateTaskRequest {
    
    @Size(min = 3, max = 255, message = "Title must be between 3 and 255 characters")
    private String title;  // Optional
    
    @Size(min = 10, max = 2000, message = "Description must be between 10 and 2000 characters")
    private String description;  // Optional
    
    private TaskStatus status;  // Optional
    
    private TaskPriority priority;  // Optional
    
    @FutureOrPresent(message = "Due date must be in the present or future")
    private LocalDateTime dueDate;  // Optional
    
    @Min(value = 0, message = "Estimated hours cannot be negative")
    @Max(value = 999, message = "Estimated hours cannot exceed 999")
    private Integer estimatedHours;  // Optional
    
    @Size(max = 1000, message = "Notes cannot exceed 1000 characters")
    private String notes;  // Optional
    
    @Positive(message = "Assignee ID must be positive")
    private Long assigneeId;  // Optional
}
```

### Key Features

**1. All Fields Optional (Partial Update)**
```java
// Only update title:
{
  "title": "Updated title"
}

// Only update status:
{
  "status": "IN_PROGRESS"
}

// Update multiple fields:
{
  "title": "New title",
  "status": "IN_PROGRESS",
  "assigneeId": 2
}
```

**2. Validation Only When Provided**
- If field is null ‚Üí not updated
- If field is provided ‚Üí validation applies
- Service layer handles null checks

**3. Cannot Update:**
- `id` - Immutable
- `projectId` - Cannot change project (business rule)
- `createdAt`, `updatedAt` - Auto-managed
- `completedAt` - Auto-set when status = COMPLETED

### Example Requests

**Change assignee:**
```json
{
  "assigneeId": 3
}
```

**Update status and completion:**
```json
{
  "status": "COMPLETED"
}
```
_(Service automatically sets `completedAt`)_

**Update multiple fields:**
```json
{
  "title": "Revised: Implement JWT authentication",
  "priority": "CRITICAL",
  "dueDate": "2025-12-18T17:00:00",
  "notes": "Deadline moved up due to security audit"
}
```

### Current Limitation

‚ùå **Cannot remove assignee:**
```json
{
  "assigneeId": null  // ‚ùå Will fail - assignee is required
}
```

**Reason:** Task entity has `@JoinColumn(nullable = false)` on assignee field.

---

## 3. UserResponse ‚úÖ NEW

**Location:** [UserResponse.java](response/UserResponse.java)

**Purpose:** Response DTO for User API endpoints

**Used by:**
- `GET /api/users` (returns List<UserResponse>)
- `GET /api/users/{id}` (returns UserResponse)
- `POST /api/users/{id}/restore` (returns UserResponse after restore)

### Structure

```java
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class UserResponse {
    
    private Long id;
    private String username;
    private String fullName;
    private String email;
    private boolean active;
    private LocalDateTime lastLoginAt;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
    
    /**
     * Factory method to convert User entity to UserResponse DTO
     */
    public static UserResponse from(User user) {
        return UserResponse.builder()
            .id(user.getId())
            .username(user.getUsername())
            .fullName(user.getFullName())
            .email(user.getEmail())
            .active(user.isActive())
            .lastLoginAt(user.getLastLoginAt())
            .createdAt(user.getCreatedAt())
            .updatedAt(user.getUpdatedAt())
            .build();
    }
}
```

### Fields

| Field | Type | Description | Source |
|-------|------|-------------|--------|
| `id` | Long | User ID | user.getId() |
| `username` | String | Login username | user.getUsername() |
| `fullName` | String | Full name | user.getFullName() |
| `email` | String | Email address | user.getEmail() |
| `active` | boolean | Account status | user.isActive() |
| `lastLoginAt` | LocalDateTime | Last login time | user.getLastLoginAt() |
| `createdAt` | LocalDateTime | Account creation | user.getCreatedAt() |
| `updatedAt` | LocalDateTime | Last update | user.getUpdatedAt() |

### Security Notes

**Fields EXCLUDED for security:**
- ‚ùå `passwordHash` - Never expose password hashes
- ‚ùå `deleted` - Internal soft delete flag
- ‚ùå `deletedAt` - Internal audit field
- ‚ùå `deletedBy` - Internal audit field
- ‚ùå `roles` - Security concern (will add when implementing RBAC)

**Why exclude deleted fields?**
- GET /api/users only returns active users (@Where filter)
- Client doesn't need deletion metadata
- Keep API response clean

### Example Response

```json
{
  "id": 1,
  "username": "john_doe",
  "fullName": "John Doe",
  "email": "john@example.com",
  "active": true,
  "lastLoginAt": "2025-12-16T10:30:00",
  "createdAt": "2025-12-01T08:00:00",
  "updatedAt": "2025-12-16T10:30:00"
}
```

### Conversion Method

**Static Factory Pattern:**
```java
// In UserService
User user = userRepository.findById(id).orElseThrow();
return UserResponse.from(user);  // ‚úÖ Clean conversion
```

**Why static factory method?**
- ‚úÖ Encapsulates conversion logic
- ‚úÖ Reusable across service layer
- ‚úÖ Single responsibility (DTO knows how to create itself)
- ‚úÖ Type-safe (compiler checks)

**Alternative approaches (not used):**
```java
// ‚ùå MapStruct (overkill for simple DTO)
// ‚ùå ModelMapper (reflection overhead)
// ‚ùå Manual mapping in service (violates SRP)
```

---

## 4. TaskResponse

**Location:** [TaskResponse.java](response/TaskResponse.java)

**Purpose:** Response DTO for all task-related endpoints

**Used by:**
- `GET /api/tasks/{id}`
- `POST /api/tasks` (after creation)
- `PUT /api/tasks/{id}` (after update)

### Structure

```java
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class TaskResponse {
    
    // Core fields
    private Long id;
    private String title;
    private String description;
    private TaskStatus status;
    private TaskPriority priority;
    
    // Dates
    private LocalDateTime dueDate;
    private LocalDateTime startDate;  // ‚ö†Ô∏è Always null (not used)
    private LocalDateTime completedAt;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
    
    // Metadata
    private Integer estimatedHours;
    private String notes;
    
    // Relationships (nested DTOs)
    private UserSummary assignee;
    private ProjectSummary project;
    
    // Counts
    private Integer commentCount;      // ‚ö†Ô∏è Always 0 (not implemented)
    private Integer attachmentCount;   // ‚ö†Ô∏è Always 0 (not implemented)
    
    // Computed fields
    private Boolean overdue;           // ‚ö†Ô∏è Not computed yet
    private Long hoursUntilDue;        // ‚ö†Ô∏è Not computed yet
    
    // Nested DTOs
    
    @Data
    @AllArgsConstructor
    @NoArgsConstructor
    @Builder
    public static class UserSummary {
        private Long id;
        private String username;
        private String fullName;
        private String email;
        // No password, no sensitive data
    }
    
    @Data
    @AllArgsConstructor
    @NoArgsConstructor
    @Builder
    public static class ProjectSummary {
        private Long id;
        private String name;
        private String description;
    }
}
```

### Conversion Method

**Static factory method in TaskResponse:**
```java
public static TaskResponse from(Task task) {
    return TaskResponse.builder()
        .id(task.getId())
        .title(task.getTitle())
        .description(task.getDescription())
        .status(task.getStatus())
        .priority(task.getPriority())
        .dueDate(task.getDueDate())
        .startDate(task.getStartDate())
        .completedAt(task.getCompletedAt())
        .estimatedHours(task.getEstimatedHours())
        .notes(task.getNotes())
        .assignee(UserSummary.builder()
            .id(task.getAssignee().getId())
            .username(task.getAssignee().getUsername())
            .fullName(task.getAssignee().getFullName())
            .email(task.getAssignee().getEmail())
            .build())
        .project(ProjectSummary.builder()
            .id(task.getProject().getId())
            .name(task.getProject().getName())
            .description(task.getProject().getDescription())
            .build())
        .commentCount(0)        // ‚ö†Ô∏è Hardcoded, should be task.getComments().size()
        .attachmentCount(0)     // ‚ö†Ô∏è Hardcoded, should be task.getAttachments().size()
        .overdue(false)         // ‚ö†Ô∏è Should check dueDate < now && status != COMPLETED
        .hoursUntilDue(0L)      // ‚ö†Ô∏è Should calculate from dueDate
        .createdAt(task.getCreatedAt())
        .updatedAt(task.getUpdatedAt())
        .build();
}
```

### Example Response

```json
{
  "id": 1,
  "title": "Implement user authentication with JWT tokens",
  "description": "Add JWT-based authentication...",
  "status": "IN_PROGRESS",
  "priority": "HIGH",
  "dueDate": "2025-12-20T17:00:00",
  "startDate": null,
  "completedAt": null,
  "estimatedHours": 16,
  "notes": "Related to security epic PROJ-123",
  "assignee": {
    "id": 1,
    "username": "john.doe",
    "fullName": "John Doe",
    "email": "john@example.com"
  },
  "project": {
    "id": 1,
    "name": "Backend API",
    "description": "Main backend REST API"
  },
  "commentCount": 0,
  "attachmentCount": 0,
  "overdue": false,
  "hoursUntilDue": 0,
  "createdAt": "2025-12-10T10:30:00",
  "updatedAt": "2025-12-14T14:20:00"
}
```

### Known Issues

‚ö†Ô∏è **Fields Not Properly Computed:**

1. **commentCount** - Always returns 0
   ```java
   // Current: .commentCount(0)
   // Should be: .commentCount(task.getComments().size())
   ```

2. **attachmentCount** - Always returns 0
   ```java
   // Current: .attachmentCount(0)
   // Should be: .attachmentCount(task.getAttachments().size())
   ```

3. **overdue** - Always returns false
   ```java
   // Should be:
   LocalDateTime now = LocalDateTime.now();
   boolean isOverdue = task.getDueDate().isBefore(now) && 
                       task.getStatus() != TaskStatus.COMPLETED;
   ```

4. **hoursUntilDue** - Always returns 0
   ```java
   // Should be:
   Duration duration = Duration.between(LocalDateTime.now(), task.getDueDate());
   long hours = duration.toHours();
   ```

5. **startDate** - Always null (field not used)

---

## ‚ö†Ô∏è Known Limitations

### 1. No User/Project DTOs

**Missing:**
```java
// These don't exist yet:
CreateUserRequest
UpdateUserRequest
UserResponse

CreateProjectRequest
UpdateProjectRequest
ProjectResponse
```

**Impact:**
- Cannot create users via API (must insert directly to DB)
- Cannot create projects via API
- Cannot get user/project details

### 2. No DTO Mappers

**Current approach:**
```java
// Manual conversion in TaskResponse
public static TaskResponse from(Task task) {
    // Manual field mapping...
}
```

**Better approach (future):**
```java
@Component
public class TaskMapper {
    TaskResponse toResponse(Task task);
    Task toEntity(CreateTaskRequest request);
    void updateEntity(UpdateTaskRequest request, Task task);
}
```

**Benefits:**
- Centralized mapping logic
- Testable
- Reusable
- Can use MapStruct for automation

### 3. No Validation Groups

**Current:**
```java
// Same validation for create and update
@Size(min = 10, max = 2000)
private String title;
```

**Better (future):**
```java
@Size(min = 10, max = 2000, groups = {Create.class, Update.class})
private String title;

// In controller:
@Validated(Create.class)
public TaskResponse create(@RequestBody CreateTaskRequest request) {...}

@Validated(Update.class)
public TaskResponse update(@RequestBody UpdateTaskRequest request) {...}
```

### 4. No Pagination DTOs

**Missing:**
```java
// These don't exist yet:
PagedResponse<TaskResponse>
PageRequest
SortRequest
```

**Current workaround:**
```java
// Returns all tasks (no pagination)
List<TaskResponse> getAllTasks();
```

---

## üìö Bean Validation Reference

### Common Annotations Used

```java
// String validation
@NotBlank                          // Not null and not empty
@NotEmpty                          // Not null and size > 0  
@Size(min = 3, max = 255)         // Length constraint
@Email                            // Valid email format
@Pattern(regexp = "...")          // Regex match

// Number validation
@NotNull                          // Not null
@Positive                         // > 0
@PositiveOrZero                   // >= 0
@Min(0)                           // >= specified value
@Max(999)                         // <= specified value

// Date/Time validation
@Past                             // Must be in past
@PastOrPresent                    // Past or now
@Future                           // Must be in future
@FutureOrPresent                  // Future or now

// Collection validation
@NotEmpty                         // Collection not empty
@Size(min = 1, max = 10)         // Collection size
```

### Custom Error Messages

```java
@NotBlank(message = "Task title is required")
@Size(min = 10, max = 2000, message = "Title must be between 10 and 2000 characters")
private String title;
```

**Response when validation fails:**
```json
{
  "timestamp": "2025-12-14T10:30:00",
  "status": 400,
  "error": "Bad Request",
  "errors": {
    "title": "Task title is required",
    "assigneeId": "Assignee ID must be positive"
  }
}
```

---

## üîÆ Planned Enhancements

### Phase 1: User & Project DTOs
```java
// User management
CreateUserRequest, UpdateUserRequest, UserResponse

// Project management
CreateProjectRequest, UpdateProjectRequest, ProjectResponse

// Comment DTOs
CreateCommentRequest, CommentResponse
```

### Phase 2: DTO Mappers
```java
@Component
public class TaskMapper {
    TaskResponse toResponse(Task task);
    Task toEntity(CreateTaskRequest request, User assignee, Project project);
    void updateEntity(UpdateTaskRequest request, Task task);
}

// Or use MapStruct:
@Mapper(componentModel = "spring")
public interface TaskMapper {
    // Auto-generated implementations
}
```

### Phase 3: Pagination
```java
@Data
public class PagedResponse<T> {
    private List<T> content;
    private int pageNumber;
    private int pageSize;
    private long totalElements;
    private int totalPages;
    private boolean first;
    private boolean last;
}
```

### Phase 4: Validation Groups
```java
public interface Create {}
public interface Update {}

@Data
public class TaskRequest {
    @NotNull(groups = Create.class)
    private String title;
    
    @Size(min = 10, groups = {Create.class, Update.class})
    private String description;
}
```

---

## üìñ Related Documentation

- [TaskController](../api/README.md) - API endpoints using these DTOs
- [TaskService](../service/README.md) - Business logic converting DTOs
- [Task Entity](../entity/README.md) - Domain model
- [Exception Handling](../exception/README.md) - Validation error responses

---

**Last Updated:** December 14, 2025  
**Version:** 0.5.0 - MVP Phase  
**Status:** Task DTOs complete, User/Project/Comment DTOs pending
